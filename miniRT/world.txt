
t_world s_world()
{
    t_world world;

    world.light = point_light(create_color((ld[3]){1, 1, 1}), create_point((ld[3]){-10, 10, -10}));
    world.obj_num = 6;
    world.objects = alloc(sizeof(t_object *) * world.obj_num, false);
    for (int i = 0; i < 6; i++)
    {
        world.objects[i] = alloc(sizeof(t_object), false);
        world.objects[i]->obj = alloc(sizeof(t_obj), false);
        world.objects[i]->obj->sphere = alloc(sizeof(t_sphere), false);
        world.objects[i]->obj->sphere->material = alloc(sizeof(t_material), false);

        world.objects[i]->type = T_SPHERE;
        // sphere(world.objects[i]->obj->sphere, NULL, false);
    }
    /*sphere 1 */
    sphere(&world.objects[0]->obj->sphere, NULL, false);
    sphere(&world.objects[0]->obj->sphere, scaling(10, 0.01, 10), true);
    world.objects[0]->obj->sphere->material->color = create_color((ld[3]){1, 0.9, 0.9});
    world.objects[0]->obj->sphere->material->specular = 0;
    
    /*sphere 2 */
    sphere(&world.objects[1]->obj->sphere, NULL, false);
    sphere(&world.objects[1]->obj->sphere, matrix_multi(translation(0, 0, 5), matrix_multi(rotation_y(-M_PI/4), rotation_x(M_PI/2))), true);
    world.objects[1]->obj->sphere->material->color = create_color((ld[3]){1, 0.9, 0.9});
    world.objects[1]->obj->sphere->material->specular = 0;

    /*sphere 3 */
    t_matrix *tran = matrix_multi(translation(0, 0, 5), matrix_multi(rotation_y(M_PI/4), rotation_x(M_PI/2)));
    sphere(&world.objects[2]->obj->sphere, NULL, false);
    sphere(&world.objects[2]->obj->sphere, tran, true);
    world.objects[2]->obj->sphere->material->color = create_color((ld[3]){1, 0.9, 0.9});

    /*sphere 4 */
    sphere(&world.objects[3]->obj->sphere, NULL, false);
    sphere(&world.objects[3]->obj->sphere, translation(-0.5, 1, 0.5), true);
    world.objects[3]->obj->sphere->material->color = create_color((ld[3]){0.1, 1, 0.1});
    world.objects[3]->obj->sphere->material->diffuse = 0.7;
    world.objects[3]->obj->sphere->material->specular = 0.3;

    /*sphere 5 */
    sphere(&world.objects[4]->obj->sphere, NULL, false);
    sphere(&world.objects[4]->obj->sphere, matrix_multi(translation(1.5, 0.5, -0.5), scaling(0.5, 0.5, 0.5)), true);
    world.objects[4]->obj->sphere->material->color = create_color((ld[3]){0.5, 1, 0.5});
    world.objects[4]->obj->sphere->material->diffuse = 0.7;
    world.objects[4]->obj->sphere->material->specular = 0.3;
    /*sphere 6 */
    sphere(&world.objects[5]->obj->sphere, NULL, false);
    sphere(&world.objects[5]->obj->sphere, matrix_multi(translation(-1.5, 0.33, 0.75), scaling(0.33, 0.33, 0.33)), true);
    world.objects[5]->obj->sphere->material->color = create_color((ld[3]){1, 0.8, 0.1});
    world.objects[5]->obj->sphere->material->diffuse = 0.7;
    world.objects[5]->obj->sphere->material->specular = 0.3;
    /****************************************************************************************/
    copy_matrix_contant(world.objects[0]->obj->sphere->inv);
    copy_matrix_contant(world.objects[1]->obj->sphere->inv);
    copy_matrix_contant(world.objects[2]->obj->sphere->inv);
    copy_matrix_contant(world.objects[3]->obj->sphere->inv);
    copy_matrix_contant(world.objects[4]->obj->sphere->inv);
    copy_matrix_contant(world.objects[5]->obj->sphere->inv);
    return world;
}

void sphere(t_sphere *sphere, t_matrixtran, bool flag)
{
    if (!sphere)
        return ;
    // t_sphere s;
    t_tupleo;
    static int id = 0;
    if (flag)
    {
        (sphere)->transform = tran;
        // (sphere)->origin = matrix_to_tuple(matrix_tuple(tran, (sphere)->origin));
        (sphere)->inv = matrix_inverte((sphere)->transform);
        return ;
    }
    // s = alloc(sizeof(t_sphere), false);
    o = alloc(sizeof(t_tuple), false);
    (sphere)->transform = identity_matrix(4, 4);
    (sphere)->inv = identity_matrix(4, 4);
    o->x = o->y = o->z = 0;
    o->w = 0.1;
    (sphere)->origin = o;
    (sphere)->radius = 1;
    (sphere)->id = id;
    // s->material = local_material();
    // *sphere = s;
    id++;
}
void obj_creator(void ** obj, t_type type)
{
    if (!sphere)
        return ;
    t_tuple o;
    t_spheres;

    s = (t_sphere )(obj);
    static int id = 0;
    o = alloc(sizeof(t_tuple), false);
    o->x = o->y = o->z = 0;
    o->w = 0.1;
    s->origin = o;
    s->radius = 1;
    s->id = id;
    id++;
}